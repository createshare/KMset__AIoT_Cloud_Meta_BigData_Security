# Security & Encryption 安全与加密



# 密码学 基础概念

密码学主要分为：编制密码、破译密码。密码学需要通过算法，提供信息的隐秘传递方式，它包括一些通信架构和
加密算法等部分。



## 密码

通信的时候双端进行信息变换和保密的方法，主要包括加密变换和脱密变换。

随着技术的发展，文字、图形、语音、图像和数据都可以进行密码变换。

根据加密方式的不同，密码的种类包括：

- 对称密码。主要有 3 种：DES、三重 DES、AES（Advanced Encryption Standard）
- 分组密码。通过密码迭代的方式，对任意长度明文进行加密，DES 和 AES 都属于分组密码。主要包括 5 种模式：ECB 模式、CTR 模式、CBC 模式、OFB 模式、CFB 模式。
- 公钥密码。主要解决了密钥输送问题，它通过公钥加密，通过私钥解密，不需要接收者接收配送的密钥。公钥和私钥必须一一对应，称为密钥对，它们之间具有密切的数学联系，无法单独生成。公钥发送给其他人，私钥只有自己握有。RSA 算法是常用的公钥密码算法。
- 混合密码。它是一种结合对称密码和公钥密码的方案，它可以提高对称密码的速度，并且使用公钥密码保护会话层。

## 认证

认证是密码学的重要组成部分，是对消息进行确认完整性和合法性的技术，一般通过发送者和接收者的密钥，识别信息的非法伪装和私自篡改等问题。

它通过密码认证协议 PAP,允许用户信息传输权限。

它确认了网络活动中用户可以获取信息的范围。它会使用消息认证码和认证函数，与密钥息息相关。

认证经常使用单向散列函数和消息认证码进行处理。

- 单向散列函数，通过输入值和输出值处理验证问题。输入的是消息，输出的是消息的散列值。
- 常用的单向散列函数在开发过程中会用到，例如，MD4、MD5、SHA-128、SHA-256、SHA-512等。SHA-256 哈希算法，成为区块链“探矿”的主要算法。
- 消息认证码。它是一种认证完整性的技术，简称 MAC（Message Authentication Code），是一种和密钥共同动作的单向散列函数。

## 数字签名

数字签名的作用是为了证明某段数据或者文件是某人的权益，从而进行签名，具有不可伪造、不可抵赖的特性。

在许多网络信息和金融交易当中，需要对某段数据或者交易进行证明，表示它的所属人员，这个时候就需要数字签名。

数字签名需要密码技术来保证其不被篡改，并且可以通过密钥生成和验证签名。

数字签名常用的方式是使用公钥加密系统，常用的算法包括：

- RSA 算法。基于对大整数进行质因数分解非常困难的原理。
- DSA 算法。基于离散对数原理。
- ECDSA 算法。DSA 的变化版本，基于椭圆曲线的离散对数原理。ECDSA 通过椭圆对称算法，使用 SHA-256 进行加密计算，其实也是一种 DSA 的算法过程。在区块链中，比特币的账户就是通过 ECDSA 进行加密的。

## 证书颁发机构 CA（certification authority）

CA是第三方机构，被你信任，由它保证证书的确发给了应该得到该证书的人。CA自己有一个庞大的public key数据库，用来颁发给不同的实体。CA也是一个实体，它也有自己的公共密钥和私有密钥。

证书颁发机构（CA）是一个值得信赖的第三方的机构（所有者），其证书值得信任。

最常见的解决方案是借助证书颁发机构（CA）做这项工作（如下图） ：在浏览器中指定哪些CA是可信任（根CA证书），CA负责验证你访问的每个网站，并进行审核，以确认这些证书没有被滥用或受损害。如果任何网站违反了CA的证书的安全性规定，那么CA有责任撤销其证书。

![证书颁发机构（CA）](figures/证书颁发机构（CA）.jpg)

## 在线证书状态协议（OCSP）

**在线证书状态协议（OCSP）：**提供一种实时检查证书状态的机制，支持验证端直接查询证书数据库中的序列号，从而验证证书是否有效。

## 证书撤销名单（CRL）

**证书撤销名单（CRL）**：每个证书颁发机构维护并定期发布一份吊销证书序列号列表。要想验证证书的可靠性，直接查询CRL名单即可。

CRL文件本身可以定期公布，或在每次更新时都公布，CRL文件可以通过HTTP，或任何其他文件传输协议传输。该名单也是由CA签名，通常允许以指定的时间间隔缓存。

偶尔证书的颁发机构可能需要撤销或作废证书，这可能由于证书的私钥被攻破了，证书颁发机构本身被攻破，或者其他一些正常的原因譬如证书替换、证书签发机构发生变化，等等。为了解决这个问题，证书本身包含了检查是否已吊销的逻辑。因此，为了确保信任链不会受到攻击影响，每个节点都可以检查每个证书的状态，连同签名。



## 证书 Certificate 

证书是建立公共密钥和某个实体之间联系的数字化的文件。它包含的内容有：版本信息（X.509 也是有三个版本的）、系列号、证书接受者名称、颁发者名称、证书有效期、公共密钥、一大堆的可选的其他信息、CA 的数字签名。证书由CA颁发，由 CA 决定该证书的有效期，由该CA签名。每个证书都有唯一的系列号。证书的系列号和证书颁发者来决定某证书的唯一身份。常用的证书是采用 X.509 结构的，这是一个国际标准证书结构。

最简单的证书包含一个公开密钥、名称以及证书授权中心的数字签名。



证书是在公钥的基础上进行数字签名，可以用来判断公钥的合法性，保障不受外部的非法攻击，它一般由认证机构来签名认证。即通过签发证书机构在证书中进行数字签名以后再发放给用户，用户可以通过证书进行机构所给权限的活动。

主要使用公钥和数字来加密，也称为公钥证书。

证书的签名和验证流程：

![证书的签名和验证流程](figures/证书的签名和验证流程.jpg)

### 证书的结构具有标准规范：

- 签名证书：包含了签名的对象数据。
- 签名算法：对证书签名使用的密码算法。
- 数字签名：证书使用的数字签名对象。

机构发放证书有一系列的规范，总称为 PKI。例如，证书在区块链的联盟链中用于处理成员授权，主要包括：

- 用户：全名用证书 PKI　的人或者机构。
- 认证机构：发放证书的人或者机构（认证中心）
- 仓库：存储证书的数据库。

### 证书中包含什么信息

- 证书信息：过期时间和序列号
- 所有者信息：姓名等
- 所有者公钥

### 为什么服务端要发送证书给客户端

- 互联网有太多的服务需要使用证书来验证身份，以至于客户端(操作系统或浏览器等)无法内置所有证书，需要通过服务端将证书发送给客户端。

### 客户端为什么要验证接收到的证书：

- 中间人攻击

- 客户端<----------------------攻击者<--------------------服务端

  ​                 伪造证书                         拦截请求



### 客户端如何验证接收到的证书

为了回答这个问题，需要引入数字签名(Digital Signature)。

将一段文本通过哈希(hash)和私钥加密处理后生成数字签名。

- 假设消息传递在Bob，Susan和Pat三人之间发生。Susan将消息连同数字签名一起发送给Bob，Bob接收到消息后，可以这样验证接收到的消息就是Susan发送的。
- 当然，这个前提是Bob知道Susan的公钥。更重要的是，和消息本身一样，公钥不能在不安全的网络中直接发送给Bob。
- 此时就引入了证书颁发机构(Certificate Authority，简称CA)，CA数量并不多，Bob客户端内置了所有受信任CA的证书。CA对Susan的公钥(和其他信息)数字签名后生成证书。
- Susan将证书发送给Bob后，Bob通过CA证书的公钥验证证书签名。
- Bob信任CA，CA信任Susan， 使得 Bob信任Susan，信任链(Chain Of Trust)就是这样形成的。
- 事实上，Bob客户端内置的是CA的根证书(Root Certificate)，HTTPS协议中服务器会发送证书链(Certificate Chain)给客户端。



## X.509  数字证书

- X.509 是密码学里公钥证书的格式标准。 X.509 证书应用在包括 TLS/SSL（ WWW 万维网安全浏览的基石）在内的众多 Internet 协议里。

- 同时它也用在很多非在线应用场景里，比如电子签名服务。
- X.509 证书里含有公钥、身份信息(比如网络主机名，组织的名称或个体名称等)和签名信息（可以是证书签发机构CA的签名，也可以是自签名）。
- 对于一份经由可信的证书签发机构签名或者可以通过其它方式验证的证书，证书的拥有者就可以用证书及相应的私钥来创建安全的通信，对文档进行数字签名。
- 另外除了证书本身功能，X.509 还附带了证书吊销列表和用于从最终对证书进行签名的证书签发机构直到最终可信点为止的证书合法性验证算法。

### X.509 数字证书结构图

![X.509 数字证书结构图](figures/X.509 数字证书结构图.jpg)

### X.509 证书基本部分

- 版本号(Version)： 标识证书的版本（版本1、版本2或是版本3）。
- 序列号(Serial Number)：标识证书的唯一整数，由证书颁发者分配的本证书的唯一标识符。
- 签名(Signature)：用于签证书的算法标识，由对象标识符加上相关的参数组成，用于说明本证书所用的数字签名算法。例如，SHA-1和RSA的对象标识符就用来说明该数字签名是利用RSA对SHA-1杂凑加密。

- 颁发者(Issuer:)：证书颁发者的可识别名（DN）。
- 有效期(Validity)：证书有效期的时间段。本字段由”Not Before”和”Not After”两项组成，它们分别由UTC时间或一般的时间表示（在RFC2459中有详细的时间表示规则）。

- 主体(Subject)：证书拥有者的可识别名，这个字段必须是非空的，除非你在证书扩展中有别名。

- 主体公钥信息(Subject Public Key Info)：主体的公钥（以及算法标识符）。

- 颁发者唯一标识符(Issuer Unique Identifier)：标识符—证书颁发者的唯一标识符，仅在版本2和版本3中有要求，属于可选项。

- 主体唯一标识符(Subject Unique Identifier)：证书拥有者的唯一标识符，仅在版本2和版本3中有要求，属于可选项。

### X.509 证书扩展部分(Extensions)

可选的标准和专用的扩展（仅在版本2和版本3中使用），扩展部分的元素都有这样的结构：

- extnID：表示一个扩展元素的 OID
- critical：表示这个扩展元素是否极重要
- extnValue：表示这个扩展元素的值，字符串类型。

```
Extension ::= SEQUENCE {
    extnID      OBJECT IDENTIFIER,
    critical    BOOLEAN DEFAULT FALSE,
    extnValue   OCTET STRING }
```

- 发行者密钥标识符(Autority Key Identifier)：证书所含密钥的唯一标识符，用来区分同一证书拥有者的多对密钥。
- 密钥使用(Key Usage)：一个比特串，指明（限定）证书的公钥可以完成的功能或服务，如：证书签名、数据加密等。如果某一证书将 KeyUsage 扩展标记为“极重要”，而且设置为“keyCertSign”，则在 SSL 通信期间该证书出现时将被拒绝，因为该证书扩展表示相关私钥应只用于签写证书，而不应该用于 SSL。
- CRL分布点(CRL Distribution Points)：指明CRL的分布地点。
- 私钥的使用期：指明证书中与公钥相联系的私钥的使用期限，它也有Not Before和Not After组成。若此项不存在时，公私钥的使用期是一样的。
- 证书策略(Certificate Policies)：由对象标识符和限定符组成，这些对象标识符说明证书的颁发和使用策略有关。
- 策略映射：表明两个 CA 域之间的一个或多个策略对象标识符的等价关系，仅在 CA 证书里存在。
- 主体别名：指出证书拥有者的别名，如电子邮件地址、IP 地址等，别名是和 DN 绑定在一起的。
- 颁发者别名：指出证书颁发者的别名，如电子邮件地址、IP 地址等，但颁发者的DN 必须出现在证书的颁发者字段。
- 主体目录属性：指出证书拥有者的一系列属性。可以使用这一项来传递访问控制信息。



### X.509 证书实例

[https://www.github.com](https://www.github.com/) 的证书信息如下：

![X.509 证书实例(GitHub)](figures/X.509 证书实例(GitHub).png)

调用 Openssl 库的 API 对 githubcom.pem 证书文件解析结果如下：

![X.509 证书实例(GitHub)_OpenSSL](figures/X.509 证书实例(GitHub)_OpenSSL.png)

### X.509 C语言解析源码

```c
#include <fstream>
#include <openssl/pem.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>
#include <iostream>
#include <sstream>

using namespace std;
//----------------------------------------------------------------------*/
void parseCert(X509* x509)
{
    cout <<"--------------------" << endl;
    BIO *bio_out = BIO_new_fp(stdout, BIO_NOCLOSE);
    //PEM_write_bio_X509(bio_out, x509);//STD OUT the PEM
    X509_print(bio_out, x509);//STD OUT the details
    //X509_print_ex(bio_out, x509, XN_FLAG_COMPAT, X509_FLAG_COMPAT);//STD OUT the details
    BIO_free(bio_out);
}

//----------------------------------------------------------------------*/
int main(int argc, char **argv)
{
    OpenSSL_add_all_algorithms();

    std::ifstream t;
    int length;
    t.open("./githubcom.pem");      // open input file
    t.seekg(0, std::ios::end);    // go to the end
    length = t.tellg();           // report location (this is the length)
    t.seekg(0, std::ios::beg);    // go back to the beginning
    char*  buffer = new char[length];    // allocate memory for a buffer of appropriate dimension
    t.read(buffer, length);       // read the whole file into the buffer
    t.close();                    // close file handle
 
    BIO *bio_mem = BIO_new(BIO_s_mem());
    BIO_puts(bio_mem, buffer);
    X509 * x509 = PEM_read_bio_X509(bio_mem, NULL, NULL, NULL);
    parseCert(x509);
    BIO_free(bio_mem);
    X509_free(x509);
}
//----------------------------------------------------------------------
```



## 申请请书 CSR

在 X.509 里，组织机构通过发起证书签名请求 ( CSR ) 来得到一份签名的证书。

首先需要生成一对钥匙对，然后用其中的私钥对 CSR 进行签名，并安全地保存私钥。

CSR 进而包含有请求发起者的身份信息、用来对此请求进行验真的的公钥以及所请求证书专有名称。

CSR 里还可能带有 CA 要求的其它有关身份证明的信息。

然后 CA 对这个专有名称发布一份证书，并绑定一个公钥。 

组织机构可以把受信的根证书分发给所有的成员，这样就可以使用公司的 PKI 系统了。



# 加密算法

## Hash 散列函数算法

- Hash 算法：Hash 算法是一种单向算法，用户可以通过Hash算法对目标信息生成一段特定长度的唯一的 Hash值，却不能通过这个Hash值逆向获得目标信息。
- Hash 散列函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性。
- 在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密。
- 常见的Hash算法：MD2、MD4、MD5、SHA、SHA-1、SHA-2 等。

## 非对称加密

- 非对称加密：指加密和解密使用不同密钥的加密算法，也称为公私钥加密。
- 算法特点是，密钥成对出现，一般称为公钥(公开)和私钥(保密)，公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。
- 因此掌握公钥的不同客户端之间不能互相解密信息，只能和掌握私钥的服务器进行加密通信，服务器可以实现1对多的通信，客户端也可以用来验证掌握私钥的服务器身份。
- 非对称加密的特点是信息传输1对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密速度慢。
- 常见的非对称加密算法：RSA、ECC、DH 、DSA（数字签名用）等。



## 对称加密

- 对称加密：指加密和解密使用相同密钥的加密算法。对称加密算法的优点在于加解密的高速度和使用长密钥时的难破解性。
- 相同的密钥可以用于信息的加密和解密，掌握密钥才能获取信息，能够防止信息窃听，通信方式是1对1。
- 对称加密的优势是信息传输1对1，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和 N 个客户端通信，需要维持 N 个密码记录，且缺少修改密码的机制。
- 常见的对称加密算法：DES、3DES、DESX、AES、RC4、RC5、RC6等。





# AES 对称加密

AES（Advanced Encryption Standard）采用 Rijndael 的加密算法，使用 SPN 作为基本网络结构，其密钥长度规范有3种: 128 比特、192 比特、256 比特。



# 公钥与私钥

公钥密码。主要解决了密钥输送问题，它通过公钥加密，通过私钥解密，不需要接收者接收配送的密钥。公钥和私钥必须一一对应，称为密钥对，它们之间具有密切的数学联系，无法单独生成。公钥发送给其他人，私钥只有自己握有。RSA、ECDSA 算法是常用的公钥密码算法。

公钥和私钥主要应用在非对称加密算法中。

公钥是公开的密码，应用在各个加密部分。公钥可以在网络上公开。

私钥是自己掌握的密钥，主要用来数据解密。

例如，在区块链的资产当中，私钥保护着用户所有的数字资产，用户最好保证私钥处于封闭的环境中，不在网络中流通，防止网络黑客。



# SSL 安全套接层协议

SSL 是 Secure Sockets Layer（安全套接层协议）的缩写，可以在 Internet 上提供秘密性传输。

SSL 是网景（Netscape）公司提出的基于 WEB 应用的安全协议。

SSL 能使用户/服务器应用之间的通信不被攻击者窃听，并且始终对服务器进行认证，还可选择对用户进行认证。

SSL 协议要求建立在可靠的传输层协议 (TCP) 之上。

SSL 协议的优势在于它是与应用层协议独立无关的，高层的应用层协议(例如：HTTP，FTP，TELNET等)能透明地建立于 SSL 协议之上。

SSL 协议在应用层协议通信之前就已经完成加密算法、通信密钥的协商及服务器认证工作。在此之后应用层协议所传送的数据都会被加密，从而保证通信的私密性。



SSL 协议指定了一种在应用程序协议 (如 HTTP、Telnet、NNTP 和 FTP等) 和 TCP/IP 协议之间提供数据安全性分层的机制，它为 TCP/IP 连接提供数据加密、服务器认证、消息完整性以及可选的客户机认证。

SSL 握手协议：SSL 包含两个子协议，一个是包协议，一个是子协议，包协议说明 SSL 的数据包是如何封装的；握手协议说明通信双方协商通信双方决定使用什么算法及算法使用的key。

## 握手协议的过程

 1) Client 向服务器发送自己支持的协议版本（如TLS1.2）、client 生成的随机数、自己加密算法的一些配置。
 2) Server 收到 Client 请求后向客户端 response:确认使用加密通信协议的版本、生成一个随机数、确认使用加密的方法、server certificate（服务器证书）。
 3) Client 验证服务器证书，在确认无误后取出其公钥，并发送随机数 Pre-Master-Key（用于公钥加密）、编码变更通知（通信双方都用商定好的密钥进行通信;即随后的信息都将用双方商定好的加密方法和密钥发送. ）
 4) Server 验证完 client 的身份之后，用自己的私有密钥解密得到 pre-master-key 后,然后双方利用这个 pre-master key 来共同协商，得到 master secret。返回信息给 client。
 5) 双方用 master 一起产生真正的 session key，这就是他们在剩下的过程中的对称加密的 key 了。这个 key 还可以用来验证数据完整性。双方再交换结束信息。握手结束。


# TLS/SSL 安全传输层协议 

TLS 安全传输层协议 Transport Layer Security 用于在两个通信应用程序之间提供保密性和数据完整性。
该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。

TLS 协议采用主从式架构模型，用于在两个应用程序间透过网络创建起安全的连接，防止在交换数据时受到窃听及篡改。

TLS/SSL 的功能实现主要依赖于三类基本算法：

- 散列函数 Hash
- 对称加密
- 非对称加密



![TLS SSL 三类基本加密算法的配合使用流程](figures/TLS SSL 三类基本加密算法的配合使用流程.jpg)

## TLS的 基本工作方式

利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数 Hush 验证信息的完整性。

结合三类算法的特点，TLS的基本工作方式。

- 客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥。
- 然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信。
- 不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。



# HTTPS 

HTTPS (Secure Hypertext Transfer Protocol)安全超文本传输协议，是一个安全通信通道，它基于 HTTP 开发用于在客户计算机和服务器之间交换信息。它使用安全套接字层 SSL 进行信息交换，简单来说它是HTTP的安全版,是使用 TLS/SSL 加密的HTTP协议。



HTTPS 能够加密信息，以免敏感信息被第三方获取。所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用 HTTPS 协议。

**浏览器和操作系统 ：**每个操作系统和大多数浏览器都包含了知名的证书颁发机构的列表。因此，你也可以信任这个软件的供应商，提供并维护的信任列表。

## HTTPS、TLS、SSL、HTTP区别和关系

HTTPS，也称作 HTTP over TLS。TLS 的前身是 SSL，TLS 1.0 通常被标示为 SSL 3.1，TLS 1.1为 SSL 3.2，TLS 1.2 为 SSL 3.3。

TLS/SSL 全称安全传输层协议 Transport Layer Security, 是介于 TCP 和 HTTP 之间的一层安全协议，不影响原有的 TCP 协议和 HTTP 协议，所以使用 HTTPS 基本上不需要对HTTP页面进行太多的改造。

## HTTP 和 HTTPS 协议的区别

1、HTTPS 协议需要到证书颁发机构 ( Certificate Authority，简称 CA ) 申请证书，一般免费证书很少，需要交费。

2、HTTP 是超文本传输协议，信息是明文传输，存在信息窃听、信息篡改和信息劫持的风险，HTTPS 则是具有安全性的 SSL 加密传输协议。

3、HTTP 和 HTTPS 使用的是完全不同的连接方式，使用的端口也不一样,前者是80,后者是443。

4、HTTP 的连接很简单,是无状态的。

5、HTTPS 协议是由S SL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比HTTP 协议安全。

从上面可看出，HTTPS 和 HTTP 协议相比提供了

- 数据完整性：内容传输经过完整性校验

- 数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥

- 身份认证：第三方无法伪造服务端(客户端)身份

- 其中，数据完整性和隐私性由 TLS Record Protocol 保证，身份认证由 TLS Handshaking Protocols 实现。

## HTTPS 的基本原理

![HTTPS 的基本原理](figures/HTTPS 的基本原理.png)

1. 客户端发起 HTTPS 请求

用户在浏览器里输入一个 HTTPS 网址，然后连接到server的443端口。

2. 服务端的配置

采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面 ( startssl 就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。

3. 传送证书

这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。

4. 客户端解析证书

这部分工作是由客户端的 TLS 来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。

5. 传送加密信息

这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。

6. 服务端解密信息

服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥(随机值)通过某种算法混合在一起，这样除非知道私钥(随机值)，不然无法获取内容，而正好客户端和服务端都知道这个私钥(随机值)，所以只要加密算法够彪悍，私钥(随机值)够复杂，数据就够安全

7. 传输加密后的信息

这部分信息是服务端用私钥(随机值)加密后的信息，可以在客户端被还原。

8. 客户端解密信息

客户端用之前生成的私钥(随机值)解密服务端传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。

## HTTPS 的通信流程和握手过程

HTTPS 在传输数据之前需要客户端(浏览器)与服务端(网站)之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL 协议不仅仅是一套加密传输的协议，更是一件经过艺术家精心设计的艺术品，TLS/SSL 中使用了非对称加密，对称加密以及HASH 算法。握手过程的具体描述如下：

1. 浏览器将自己支持的一套加密规则发送给网站。

2. 网站从中选出一组加密算法与 HASH 算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。

3. 浏览器获得网站证书之后浏览器要做以下工作：

- a) 验证证书的合法性(颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等)，如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。
- b) 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。
- c) 使用约定好的 HASH 算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。

4. 网站接收浏览器发来的数据之后要做以下的操作：

- a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证 HASH 是否与浏览器发来的一致。
- b) 使用密码加密一段握手消息，发送给浏览器。

5. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。
