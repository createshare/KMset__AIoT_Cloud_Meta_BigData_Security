# RTOS Low Power 低功耗

- 随着物联网 (IoT) 的兴起，产品对功耗的需求越来越强烈。作为数据采集的传感器节点通常需要在电池供电时长期工作，而作为联网的 SOC 也需要有快速的响应功能和较低的功耗。  
- 高性能与有限的电池能量在嵌入式系统中矛盾最为突出。

- 硬件低功耗设计与软件低功耗管理的联合应用成为解决矛盾的有效手段。  

- 现在的各种 MCU 都或多或少的在低功耗方面提供了管理接口  
  - 对主控时钟频率的调整  
  - 工作电压的改变  
  - 总线频率的调整甚至关闭  
  - 外围设备工作时钟的关闭等  

- 低功耗管理是一项十分细致的任务，开发者在移植时，不仅需要充分了解芯片本身的功耗管理，还需熟悉板卡的外围电路  

## 低功耗管理分为三个类别  

- 处理器电源管理主要实现方式：对 CPU 频率的动态管理，以及系统空闲时对工作模式的调整。
- 设备电源管理主要实现方式：关闭个别闲置设备
- 系统平台电源管理主要实现方式：针对特定系统平台的非常见设备具体定制。  





# ■■■■■■■■■■■■■■■■■■■■■■■

# 一般方法：实现低功耗（优化功耗）

可以从以下 几个角度，进行优化。

## 硬件角度，降低功耗

- 选择比较好的 MCU 和射频芯片。（例如，以前都用 CC1101，现在基本换成其他芯片了。MCU 一般选择 Cortex-M0+ 的超低功耗的 MCU）

- 如果需要上拉电阻，尽量先大一点的上位电阻。因为，例 3V 的电源，用 1M 的上拉电阻，就会产生 3 uA 的静态电流。

- 外部电路，例按键电路，我们会通过 2 个 GPIO 来实现按键。这样比较省电。当需要采样按键值时，用一个 GPIO 对按键电路供电。另一个 GPIO 用来采样按键是否按下。平时，则处于断电模式，不会耗电。便要注意，RC 电路的取值。

- 注：时间常数  RC 电路有个时间常数 T = R x C。根据公式可知，当 R x C 越大，时间常数越大，积分电路充放电就慢。反之，当 R x C 越小，时间常数越小，积分电路充放电就快。

- 尽量少用 I2C 通信接口。（ 2 个上拉电阻，静态电流，比较大）

- 时钟的选择也很重要。（一般用 MCU 内部 RC 作为时钟源，但精度不够，需要用高精度的时钟来较校准这个内部的 RC 时钟源。）

- 清空 DMA  

- 不用的 GPIO，设置 IO 为复位状态 

- 根据 外围硬件电路，设置相关 GPIO 的输出电平，避免出现外围电路漏电拉升整体功耗的情况。  

  

## 软件角度，降低功耗

- 把整个中断向量表，在芯片初始化时，全部复制到 RAM 中，并重定向到 RAM。
- 同理，将经常调试的代码，从 Flash 拷贝到 RAM 中运行，以提高程序运行的速度，从而降低功耗（即尽快回到低功耗模式）。
  - 例如， IAR 下，可使用 “__ramfunc” 关键字。可以在同样的系统时钟，运行更快，进一步减少功耗，可以省个5%的功耗。（说白了，就是以空间换时间）
  - ramfunc 来声明将某个函数放到 RAM 中运行。该函数用 ramfunc 声明后，编译器将这段程序和其他需要初始化的变量，放在一个具有读/写属性的区域（SECTION）。系统启动时，自动和其他的需要初始化的变量，一起从 ROM 拷贝到 RAM。
  - 使用 __ramfunc 关键字的缺点，就是不能指定具体的 RAM 位置。而且在 ramfunc 的函数中调试不是 ramfunc 的函数会降低执行速度。
- While 循环里面代码、驱动，尽量不要调库，直接对芯片的寄存器操作。
- 减少一些函数的嵌套，减少出栈入栈所消耗的时间。尽可能地减少指令周期。
  - 主循环中核心代码，减少库函数的调用，通过对寄存器直接操作，来减少函数嵌套，同时提高运行速度，来降低功耗。
  - 初始化时，倒是可以使用库函数。例如，STM32 的 HAL 相关的驱动库函数。
- 提高 "常用（经常被调用）的代码" 的运行速度，从而让芯片尽早运行完代码，减少总的运行时间，快速回来低功耗状态。
  - 方法 01：变频，MCU 在运行时，提高主时钟，提高代码运行效率
  - 方法 02：可以 “以空间换时间” 的方法。例如，对于 AES 算法，可以提前到 AES 表格提前存到 Code Flash，采用查表方法实现AES 算法。
  - 方法 03：利用芯片一些硬件模块，来提速。例如，AES 硬件加速器、浮点运算单元。
  - 方法 04：可以使用  register 关键字（对于嵌入式 C 语言）
    - 当对一个变量频繁被读写时，需要反复访问内存，从而花费大量的存取时间。为此，C语言提供了一种变量，即寄存器变量。这种变量存放在CPU的寄存器中，使用时，不需要访问内存，而直接从寄存器中读写，从而提高效率。

# ■■■■■■■■■■■■■■■■■■■■■■■

# RTOS 实现低功耗

- MCU 实现低功耗本质而言便是停止 MCU 工作，通过中断的方式重新唤醒 MCU，这些中断可以包括外部 IO 中断，UART 接收中断，定时器中断等等。
- 但是在 uCOS、FreeRTOS 之类的操作系统，实现这一模式就有点麻烦，最大的问题是任务切换是无法控制的，经常出现唤醒之后程序跑飞的情况。
- 利用操作系统进入和退出低功耗模式，需要熟悉嵌入式操作系统的空任务和系统滴答时钟中断。
- 结合嵌入式操作系统，**可以在空任务或者空任务钩子函数中进入低功耗模式，在系统滴答时钟中断服务函数中重新回到正常工作模式。**
- 要把休眠的代码段放在低优先级任务中，不一定是系统自带的空闲任务，也可以是用户自定义的最低优先级的任务。



## 方法 1：空任务或者空任务钩子函数中进入低功耗模式

- 因为系统要响应系统节拍中断事件，因此使用这种方法会周期性的退出、再进入低功耗状态。
- 如果系统节拍中断频率过快，则大部分电能和CPU时间会消耗在进入和退出低功耗状态上。
- 空任务优先级最低且一直保持就绪状态，空任务可以用于统计 CPU 使用率，或者让 MCU 进入低功耗状态。如果不想修改空任务，还可以通过空任务的钩子函数插入实现低功耗的代码。
- 以 FreeRTOS 为例
  - 空闲钩子设置低功耗时，需要在 FreeRTOSConfig.h 中，将宏 configUSE_IDLE_HOOK 置为 1，然后自己实现固定接口：void vApplicationIdleHook(void );
  - 同时， 这个钩子函数不可以调用会引起空闲任务阻塞的API函数（例如：vTaskDelay()、带有阻塞时间的队列和信号量函数），在钩子函数内部使用协程是被允许的。
  - 在空闲任务钩子函数中设置微处理器进入低功耗模式来达到省电的目的。



## 方法 2：Tickless 无系统滴答时钟方式实现低功耗

- Tickless 低功耗机制是当前小型 RTOS 所采用的通用低功耗方法，比如 FreeRTOS, embOS，RTX 和 uCOS-III （类似方法）都有这种机制。
- 当用户任务都被挂起或者阻塞时，最低优先级的空闲任务会得到执行。那么 STM32 支持的睡眠模式，停机模式就可以放在空闲任务里面实现。
- 为了实现低功耗最优设计，我们还不能直接把睡眠或者停机模式直接放在空闲任务就可以了。
- RTOS 的系统时钟是由嘀嗒定时器中断来提供的，系统时钟频率越高，嘀嗒定时器中断频率也就越高。如果嘀嗒定时器中断频率太高的话会导致大量的能量和时间消耗再进出睡眠模式中，这样导致的结果就是低功耗模式的作用被大大的消弱。

### Tickless Idle Mode 的软件设计原理

Tickless Idle Mode 的设计思想在于：尽可能地在 MCU 空闲时使其进入低功耗模式，软件设计时，需要解决以下问题：

- 合理的进入低功耗模式（避免频繁使 MCU 在低功耗模式和运行模式下进行不必要的切换）
  - RTOS 的系统时钟源于硬件的某个周期性定时器（Cortex-M 系列内核多数采用 SysTick)
  - RTOS 的任务调度器可以预期到下一个周期性任务（或者定时器任务）的触发时间。
  - 如上文所述，进入空闲任务后，首先要计算可以执行低功耗的最大时间，也就是求出下一个要执行的高优先级任务还剩多少时间。
  - 然后就是把低功耗的唤醒时间设置为这个求出的时间，**调整系统时钟定时器中断触发时间**，到时间后系统会从低功耗模式被唤醒，继续执行多任务。
  - 这个就是所谓的 tickless 模式。，可以避免 RTOS 进入不必要的时间中断，从而更长的时间停留在低功耗模式中。
  - 此时 RTOS 的时钟不再是周期的而是动态的。在原有的时钟基准时将不再产生中断，即 Tickless。

- 当 MCU 被唤醒时，通过某种方式提供为系统时钟提供补偿
  - MCU 可能被两种情况所唤醒
    - 动态调整过的系统时钟中断。
    - 或者突发性的外部事件（其他中断发生）。
  - 无论是哪一种情况，都可以通过运行在低功耗模式下的某种定时器来计算出 MCU 处于低功耗模式下的时间，在 MCU 唤醒后对系统时间进行软件补偿。
- 软件实现时，要根据具体的应用情景和 MCU 低功耗特性来处理问题。
  - 尤其是 MCU 的低功耗特性，不同 MCU 处于不同的低功耗模式下所能使用的外设（主要是定时器）是不同的，RTOS的系统时钟可以进行适当的调整。

- 实现 Tickless 模式最麻烦是低功耗可以执行的时间如何获取。
  - 关闭嘀嗒定时器会导致系统节拍停止，系统时钟就会停止
    - 例如，可以再用另外的定时器，记录下系统节拍中断的关闭时间，当系统节拍中断再次开启运行的时候补上这段时间。
  - 如何保证下一个要运行的任务能被准确的唤醒
    - 在进入低功耗模式之前获取还有多长时间进行下一个任务。

### 使用案例：FreeRTOS + STM32 + Tickless

- \#define configUSE_TICKLESS_IDLE   1  //启用低功耗模式
-  使能 Tickless 后，符合下面两种情况会调用宏 portSUPPRESS_TICKS_AND_SLEEP() 来处理低功耗的工作
  - 空闲任务是唯一可运行的任务，因为其他所有任务都处于阻塞态或挂起态
  - 系统处于低功耗模式的时间至少大于 configEXPECTED_IDLE_TIME_BEFORE_SLEEP 个时钟节拍，宏configEXPECTED_IDLE_TIME_BEFORE_SLEEP默认在文件FreeRTOS.h中定义为 2，重新定义大于 2。
- 由于在 STOP 下，为 FreeRTOS 提供心跳时钟的 SYSTICK 也停止了工作，所以，在被唤醒之后，还需要将在 STOP 下流逝的时间告诉 FreeRTOS。
- 总之，降低整个产品功耗的基本思想，就是让 FreeRTOS 仅可能多的时间处于 IDLE 任务，让 STM32 尽可能多的时间处于 STOP 模式，最终达到尽可能多的降低功耗的目的。



## 方法 3：低功耗设计中，还需要做一些特殊处理

- 对主控时钟频率的调整。将处理器降低到合适的频率，因为频率越低功耗越小，甚至可以在进入低功耗以后关闭系统时钟。
- 修改时钟源，晶振的功耗肯定比处理器内部的时钟源高，进入低功耗模式以后可以切换到内部时钟源，比如 STM32 的内部 RC 振荡器。
- 关闭其他外设时钟，比如IO口的时钟。
- 改变工作电压。
- 关闭板子上其他功能模块电源，这个需要在产品硬件设计的时候就要处理好，比如可以通过MOS管来控制某个模快电源的开关，在处理器进入低功耗模式之前关闭这些模块的电源。
- 需熟悉板卡的外围电路，进入低功耗状态时逐一处理，避免出现外围电路漏电拉升整体功耗的情况。  



# ■■■■■■■■■■■■■■■■■■■■■■■

# 低功耗 常见问题及调试方法  

## 问题 01：系统进入低功耗模式后功耗偏高  

- 根据外围电路，检查设备是否处于合理状态，避免出现外设漏电的情况。
  - 例如 GPIO 状态（输入或输出）、输出时，是输出高电平还是低电平。
- 根据产品自身情况，关闭相应休眠模式期间不使用的外设和时钟。  



## 问题 02：无法进入更低等级的功耗  

- 检查在进入更低等级的功耗时，是否有按数据手册进行相关操作：
  - 将相关的电源模块禁用
  - 调整相关的时钟配置
  - 禁用无法在 “更低等级”模式下工作的模块等。



# ■■■■■■■■■■■■■■■■■■■■■■■



![XXX](figures/XXX.jpg)



