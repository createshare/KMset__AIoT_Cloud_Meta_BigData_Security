# RTOS Bug 常见问题、原因分析、解决方案

使用 RTOS 会使调试复杂化。

RTOS 可能会引入诸如优先级反转、死锁和任务抖动等问题。



# ■■■■■■■■■■■■■■■■■■■■■■

# 互斥量 vs 二值信号量 

- 拥有互斥量的线程拥有互斥量的所有权，互斥量支持递归访问且能防止线程**优先级翻转**；  
- 持有该互斥量的线程也能够再次获得这个锁而不被挂起，这就是**递归访问**。
- 并且互斥量只能由持有线程释放，而信号量则可以由任何线程释放。  
-  在信号量中， 由于已经不存在可用的信号量，线程递归获取信号量时会发生主动挂起（最终形成**死锁**） 。  
- 如果想要用于实现同步（线程之间或者线程与中断之间）， 二值信号量或许是更好的选择， 虽然互斥量也可以用于线程与线程、 线程与中断的同步，但是互斥量更多的是用于保护资源的互锁。用于互锁的互斥量可以充当保护资源的令牌。  
- 用于临界资源的保护一般建议使用互斥量。  
- 注意的是互斥量不能在中断服务函数中使用。 
  - 其他能挂起的操作也都不能用在中断中。 
  - 因为互斥锁上的锁定操作可以睡眠，并且在 ISR 中睡眠是非法的。导致中断无法退出，系统无法正常调试。如果您在中断时进行任何阻塞调用，则调度程序将永远不会运行。
  - 系统中，有一个线程上下文和一个中断上下文。中断由硬件调用，而线程由RTOS调度程序调度。现在当中断发生时，任何线程都将立即被抢占;中断必须运行完成，只能被优先级较高的中断（支持嵌套中断）抢占。所有挂起的中断将在调度程序运行之前运行完毕。
  - 请改用自旋锁。在中断处理程序中可以使用自旋锁”意思是使用自旋锁即使它一时获取不到需要的资源，也会在那里自旋，不会让出处理器，而导致睡眠。



# 优先级反转

## 现象：

- 优先级反转是实时系统中的一个问题，当使用基于优先级的抢占式内核时会发生。
- 使用信号量会导致的另一个潜在问题是线程优先级翻转问题。  
  - 所谓优先级翻转，即当一个高优先级线程试图通过信号量机制访问共享资源时，如果该信号量已被一低优先级线程持有，而这个低优先级线程在运行过程中可能又被其它一些中等优先级的线程抢占，因此造成高优先级线程被许多具有较低优先级的线程阻塞，实时性难以得到保证。  
  - 有优先级为 A、 B 和 C 的三个线程，优先级 A> B > C。
  - 线程 A， B 处于挂起状态，等待某一事件触发，线程 C 正在运行，此时线程 C 开始使用某一共享资源 M。
  - 在使用过程中，线程 A 等待的事件到来，线程 A 转为就绪态，因为它比线程 C 优先级高，所以立即执行。
  - 但是当线程 A 要使用共享资源 M 时，由于其正在被线程 C 使用，因此线程 A 被挂起切换到线程 C 运行。
  - 如果此时线程 B 等待的事件到来，则线程 B 转为就绪态。
  - 由于线程 B 的优先级比线程 C 高，因此线程 B 开始运行，直到其运行完毕，线程 C 才开始运行。
  - 只有当线程 C 释放共享资源 M 后，线程 A 才得以执行。
  - 在这种情况下，优先级发生了翻转：线程 B 先于线程 A 运行。
  - 这样便不能保证高优先级线程的响应时间。  
- 优先级翻转的危害很大
  - 发生优先级翻转，对我们操作系统是致命的危害，会导致系统的高优先级线程阻塞时间过长。  
  - 假如很多个这样子的（中等优先级）线程打断最低优先级的线程，那这个系统最高优先级线程岂不是崩溃了。特别是对时序要求比较严格的系统。

## 解决方案：避免优先级反转

- 可以使用 RTOS 的互斥量机制来解决上面描述的优先级反转问题。互斥量可以解决优先级翻转问题，实现的是**优先级继承算法**。
  - 优先级继承是通过在线程 A 尝试获取共享资源而被挂起的期间内，将线程 C 的优先级提升到线程 A 的优先级别，从而解决优先级翻转引起的问题。
  - 这样能够防止 C（间接地防止 A）被 B 抢占。
  - 优先级继承是指，提高某个占有某种资源的低优先级线程的优先级，使之与所有等待该资源的线程中优先级最高的那个线程的优先级相等，然后执行，而当这个低优先级线程释放该资源时，优先级重新回到初始设定。
  - 因此，继承优先级的线程避免了系统资源被任何中间优先级的线程抢占。  
  - 这个优先级继承机制确保高优先级线程进入阻塞状态的时间尽可能短，以及将已经出现的 “优先级翻转” 危害降低到最小。但要完全消除需要在设计时避免。
  
- 注意：在获得互斥量后，请尽快释放互斥量，并且在持有互斥量的过程中，不得再行更改持有互斥量线程的优先级。  

- 使用 Tracealyzer 的执行实例视图，开发者立刻就能发现问题。

  ![优先级翻转, 优先级继承](figures/优先级翻转, 优先级继承.png)



# 死锁

## 现象：

- 死锁是至少两个任务相互等待另一个任务拥有的资源，导致任务都无法继续进行，就会发生死锁。
- 死锁可能不会立即发生，它很大程度上取决于两个任务何时需要彼此的资源。
- 例如， 在信号量中， 由于已经不存在可用的信号量，线程递归获取信号量时会发生主动挂起（最终形成**死锁**） 。  

## 检测方法：

- 通过监视/显示每个任务的执行频率（RTOS 切换任务的频率）, 来检测是否有死锁。
- 任务中加放一些计数器，如果至少两个任务的计数出现停止，则可能存在死锁。

## 解决方案：避免死锁

- 在设计时避免死锁的发生，如所有的任务都按照固定的顺序使用共享资源，或者同一时间任务不持有多个共享资源。
- 任务先获取所有必需的资源，以相同的顺序获取它们，以相反的顺序释放它们。
- 在 RTOS API 调用中使用超时机制，以避免永远等待资源可用。
- 检查 RTOS API 返回的错误代码，以确保对所需资源的请求成功。



