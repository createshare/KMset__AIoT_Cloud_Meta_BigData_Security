# RTOS Bug 常见问题、原因分析、解决方案

使用 RTOS 会使调试复杂化。

RTOS 可能会引入诸如优先级反转、死锁和任务抖动等问题。



# ■■■■■■■■■■■■■■■■■■■■■■

# 互斥量 vs 二值信号量 

- 拥有互斥量的线程拥有互斥量的所有权，互斥量支持递归访问且能防止线程**优先级翻转**；  
- 持有该互斥量的线程也能够再次获得这个锁而不被挂起，这就是**递归访问**。
- 并且互斥量只能由持有线程释放，而信号量则可以由任何线程释放。  
-  在信号量中， 由于已经不存在可用的信号量，线程递归获取信号量时会发生主动挂起（最终形成**死锁**） 。  
- 如果想要用于实现同步（线程之间或者线程与中断之间）， 二值信号量或许是更好的选择， 虽然互斥量也可以用于线程与线程、 线程与中断的同步，但是互斥量更多的是用于保护资源的互锁。用于互锁的互斥量可以充当保护资源的令牌。  
- 用于临界资源的保护一般建议使用互斥量。  
- 注意的是互斥量不能在中断服务函数中使用。 
  - 其他能挂起的操作也都不能用在中断中。 
  - 因为互斥锁上的锁定操作可以睡眠，并且在 ISR 中睡眠是非法的。导致中断无法退出，系统无法正常调试。如果您在中断时进行任何阻塞调用，则调度程序将永远不会运行。
  - 系统中，有一个线程上下文和一个中断上下文。中断由硬件调用，而线程由RTOS调度程序调度。现在当中断发生时，任何线程都将立即被抢占;中断必须运行完成，只能被优先级较高的中断（支持嵌套中断）抢占。所有挂起的中断将在调度程序运行之前运行完毕。
  - 请改用自旋锁。在中断处理程序中可以使用自旋锁”意思是使用自旋锁即使它一时获取不到需要的资源，也会在那里自旋，不会让出处理器，而导致睡眠。



# 优先级反转

## 现象：

- 优先级反转是实时系统中的一个问题，当使用基于优先级的抢占式内核时会发生。
- 使用信号量会导致的另一个潜在问题是线程优先级翻转问题。  
  - 所谓优先级翻转，即当一个高优先级线程试图通过信号量机制访问共享资源时，如果该信号量已被一低优先级线程持有，而这个低优先级线程在运行过程中可能又被其它一些中等优先级的线程抢占，因此造成高优先级线程被许多具有较低优先级的线程阻塞，实时性难以得到保证。  
  - 有优先级为 A、 B 和 C 的三个线程，优先级 A> B > C。
  - 线程 A， B 处于挂起状态，等待某一事件触发，线程 C 正在运行，此时线程 C 开始使用某一共享资源 M。
  - 在使用过程中，线程 A 等待的事件到来，线程 A 转为就绪态，因为它比线程 C 优先级高，所以立即执行。
  - 但是当线程 A 要使用共享资源 M 时，由于其正在被线程 C 使用，因此线程 A 被挂起切换到线程 C 运行。
  - 如果此时线程 B 等待的事件到来，则线程 B 转为就绪态。
  - 由于线程 B 的优先级比线程 C 高，因此线程 B 开始运行，直到其运行完毕，线程 C 才开始运行。
  - 只有当线程 C 释放共享资源 M 后，线程 A 才得以执行。
  - 在这种情况下，优先级发生了翻转：线程 B 先于线程 A 运行。
  - 这样便不能保证高优先级线程的响应时间。  
- 优先级翻转的危害很大
  - 发生优先级翻转，对我们操作系统是致命的危害，会导致系统的高优先级线程阻塞时间过长。  
  - 假如很多个这样子的（中等优先级）线程打断最低优先级的线程，那这个系统最高优先级线程岂不是崩溃了。特别是对时序要求比较严格的系统。

## 解决方案：避免优先级反转

- 可以使用 RTOS 的互斥量机制来解决上面描述的优先级反转问题。互斥量可以解决优先级翻转问题，实现的是**优先级继承算法**。
  - 优先级继承是通过在线程 A 尝试获取共享资源而被挂起的期间内，将线程 C 的优先级提升到线程 A 的优先级别，从而解决优先级翻转引起的问题。
  - 这样能够防止 C（间接地防止 A）被 B 抢占。
  - 优先级继承是指，提高某个占有某种资源的低优先级线程的优先级，使之与所有等待该资源的线程中优先级最高的那个线程的优先级相等，然后执行，而当这个低优先级线程释放该资源时，优先级重新回到初始设定。
  - 因此，继承优先级的线程避免了系统资源被任何中间优先级的线程抢占。  
  - 这个优先级继承机制确保高优先级线程进入阻塞状态的时间尽可能短，以及将已经出现的 “优先级翻转” 危害降低到最小。但要完全消除需要在设计时避免。
  
- 注意：在获得互斥量后，请尽快释放互斥量，并且在持有互斥量的过程中，不得再行更改持有互斥量线程的优先级。  

- 使用 Tracealyzer 的执行实例视图，开发者立刻就能发现问题。

  ![优先级翻转, 优先级继承](figures/优先级翻转, 优先级继承.png)



# 死锁

## 现象：

- 死锁是至少两个任务相互等待另一个任务拥有的资源，导致任务都无法继续进行，就会发生死锁。
- 死锁可能不会立即发生，它很大程度上取决于两个任务何时需要彼此的资源。
- 例如， 在信号量中， 由于已经不存在可用的信号量，线程递归获取信号量时会发生主动挂起（最终形成**死锁**） 。  

## 检测方法：

- 通过监视/显示每个任务的执行频率（RTOS 切换任务的频率）, 来检测是否有死锁。
- 任务中加放一些计数器，如果至少两个任务的计数出现停止，则可能存在死锁。

## 解决方案：避免死锁

- 在设计时避免死锁的发生，如所有的任务都按照固定的顺序使用共享资源，或者同一时间任务不持有多个共享资源。
- 任务先获取所有必需的资源，以相同的顺序获取它们，以相反的顺序释放它们。
- 在 RTOS API 调用中使用超时机制，以避免永远等待资源可用。
- 检查 RTOS API 返回的错误代码，以确保对所需资源的请求成功。



# 线程饥饿

## 现象：

- 在嵌入式多任务系统中，一些任务可能会执行缓慢，或者甚至得不到执行，常见的原因是由于优先级顺序设置不正确导致。
- 高优先级的任务使用了太多的 CPU 时间，低优先级的任务可能就没有足够的时间执行，这就是所谓的线程饥饿。
- 饥饿的影响是响应性和产品特性的下降，例如嵌入式目标的显示更新缓慢、通信堆栈中的数据包丢失、操作界面响应迟缓等。

## 解决方案：解决饥饿问题

- 优化消耗大多数CPU 带宽的代码。例如，减少该任务/线程的时间片
- 高优先级应该保留给可预测、循环执行、且循环周期较短的任务。
- 对于高优先级、CPU占用时间长的任务应该拆分为多个任务，缩小时间关键代码，通过任务同步机制，将占用CPU时间多的工作交给中或低优先级任务处理。
- 将受影响的任务的优先级提高，确实可以改善问题，但违背了使用优先级的意义。



# 线程抖动

## 现象：

- 周期性执行的任务，随机发生的延迟时间叫做**抖动**。

- 虽然轻微的抖动很难避免，但是抖动太严重就会导致性能变差，间歇性的数据丢失。

- 例如，每隔 5 ms 调整电机的控制参数，如果控制任务的抖动过大就会使得控制性能就变差。

- 除了线程饥饿会导致抖动之外，RTOS 系统配置也会有影响，例如系统节拍定时器节拍频率。

  

## 解决方案：

- 理想情况下，两个节拍之间的时间应该比系统中最频繁任务的周期时间短得多。
- 使用 Tracealyzer 通过记录任务执行的时间，在以时间为坐标的图上很快可以发现抖动很大的执行实例，假如这是对抖动敏感的任务，这可能就是导致系统问题的原因了。

# ■■■■■■■■■■■■■■■■■■■■■■

# 中断相关

## 中断嵌套：不同 CPU 中断状态下切换到线程上下文说明

### 问题说明

关于中断嵌套情况下的，中断返回问题的疑问，情况如下：

- 首先发生较低优先级的中断
- 该低优先级中断被高优先级中断打断
- 在高优先级中断里释放信号量唤醒线程
- 在高优先级中断退出时，是否会出现直接切换到线程，而回到到低优先级中断的情况

### 问题解释

上述问题发生在允许中断嵌套的情况下，针对这个问题，需要讨论两类不同的 CPU 中断设计：

- 第一类 CPU：进入中断的同时会屏蔽同类型的中断，如 IRQ 或 FIQ，例如 cortex-A 系列
  - 对于第一类 CPU，这种 CPU 比较常见，例如 cortex-A 系列等。
  - 在 RT-Thread 操作系统中，进入中断后，**需要先将 `rt_interrupt_nest` 加一后再打开中断**，这就能确保即使该中断被更高优先级的中断打断返回，`rt_interrupt_nest` 的值仍然至少为 1，这就使得此时不会通过调度函数切换到线程上下文，而是必须等到最低一级中断完全处理完后，进行中断退出时，才会切换回线程状态。
  - 通过这种方式可以保证，如果中断没有完全退出，是不可能越过低级别的中断处理，直接切换到线程状态的。

- 第二类 CPU：进入中断时不会屏蔽中断，这种 CPU 会在进入中断时会自动保存一部分程序现场，例如 cortex-M系列
  - 对于第二类 CPU（例如 cortex-M），CPU 必须提供自动保存一部分上下文的功能，以避免中断被打断，造成现场破坏的问题。
  - 以 cortex-M 系列 CPU 为例，其线程切换总是在 `pendSV` 中进行，而 `pendSV` 是一种异常级别最低的异常。
  - 因此，从硬件机制上保证了线程的切换操作只能在所有的中断都退出的情况下进行。也就不可能发生中断没有完全退出而直接切换到线程的情形。



# ■■■■■■■■■■■■■■■■■■■■■■

# 堆栈溢出 

## 现象： 

- 在基于实时内核的应用中，每个任务都需要自己的堆栈。任务所需堆栈的大小取决于应用程序。如果堆栈大于任务要求，则会浪费内存。如果堆栈太小，堆栈可能溢出。 

- 一些CPU，比如基于 ARMv8M 架构的 CPU，内置了堆栈溢出检测机制。然而，该特性并不能帮助确定合适的堆栈大小，它只是防止堆栈溢出的负面后果。 

 

## 解决方案： 

- 堆栈分配时，首先为任务堆栈分配更多空间，然后在已知最坏情况下运行应用程序，监视实际堆栈使用情况。 
- 我们可以通过分配更多内存来减少堆栈溢出的机会，通常需要 **25-50%** 的额外堆栈空间。 
- 线程栈大小可以这样设定
  - 对于资源相对较大的 MCU，可以适当设计较大的线程栈。
  - 也可以在初始时设置较大的栈，例如指定大小为 1K 或 2K 字节，然后在 FinSH 中用 list_thread 命令查看线程运行的过程中线程所使用的栈的大小，通过此命令，能够看到从线程启动运行时，到当前时刻点，线程使用的最大栈深度，而后加上适当的余量形成最终的线程栈大小，最后对栈空间大小加以修改。

# ■■■■■■■■■■■■■■■■■■■■■■

# 代码优化问题

## 代码二级优化问题

### 现象： 

- 发现代码二级优化后，线程初始化异常，程序无法正常运行下去。

### 原因分析： 

- 出现这种问题的原因是对汇编相关的编程规范不够熟悉，
- 代码不支持二级优化的问题是由于先前支持 VFP 时留下的隐患，当用汇编实现 `vfp` 的栈初始化函数时，不清楚要遵循 **C 语言调用汇编语言的编程规范**，使用了 R5 R6 寄存器但是却没有保存并恢复他们的状态，这就导致了调用该函数的上下文被破坏，导致一些赋值异常，进而导致线程初始化异常，线程无法正常运行。
- 为什么问题只在二级优化的时候出现呢？
  - 经过测试发现当使用 O0 优化时，编译器在翻译代码时只只用了 R0-R3 寄存器，没有使用到我实现函数中所用到的 R5 R6，因此这个问题被掩盖了。
  - 当编译器开启二级优化时，**优化后的汇编代码使用了 R4-R11 等这些寄存器**，由于我在函数中改掉了这些寄存器，因此造成了编译器输出的汇编代码运行异常。

### 结论： 

- 这说明，在不同的优化等级下，编译器给出的机器码可能会选择不同的寄存器来完成相同功能的操作。
- 自己编写的汇编代码对于编译器来说是无法感知的，因此可能会破坏编译器规划的程序流，进而导致程序运行失败。
